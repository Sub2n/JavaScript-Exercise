<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Carousel Slider</title>
  <style>
    @import url(https://fonts.googleapis.com/css?family=Open+Sans:300,400);

    body {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      color: #58666e;
      background-color: #f0f3f4;
    }

    /*
      carousel의 window 역할을 한다.
      하나의 carousel-item의 width/height로 크기를 조절하고 overflow: hidden;으로 넘치는 자식 요소를 숨길 것이다.
      carousel-item의 width/height는 가변이므로 carousel의 width/height는 첫번째 carousel-item의 width/height를 자바스크립트로 취득해 셋팅할 것이다
     */
    .carousel {
      position: relative;
      margin: 0 auto;
      overflow: hidden;
      /* carousel 요소의 width/height의 셋팅이 완료될 때까지 감춘다. */
      opacity: 0;
      border: 1px dotted red; /* for test */

    }

    .carousel-item-container {
      /* 수평 정렬 */
      display: flex;
    }

    .carousel-item {
      padding: 5px;
    }

    .carousel-item img {
      /* image 요소 아래에 패딩된 여분의 공간 제거하기 */
      vertical-align: bottom;
    }

    /* carousel의 prev, next 버튼 */
    .carousel-control {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 2em;
      color: #fff;
      background-color: transparent;
      border-color: transparent;
      cursor: pointer;
      z-index: 99;
    }

    .carousel-control:focus {
      outline: none;
    }

    /* carousel의 prev 버튼 */
    .carousel-control.prev {
      left: 0;
    }

    /* carousel의 next 버튼 */
    .carousel-control.next {
      right: 0;
    }

    .carousel-control.disabled {
      opacity: 0.5;
    }

    /* For Test */
    .carousel {
      overflow: visible;
    }

    /* For Test */
    #overflow:checked + .carousel {
      overflow: hidden;
    }
  </style>
</head>
<body>
  <label for="overflow">carousel <b>overflow: hidden</b></label>
  <input type="checkbox" id="overflow" checked>

  <div class="carousel">
    <div class="carousel-item-container">
      <div class="carousel-item">
        <a href="#">
          <img src="http://via.placeholder.com/400x150/3498db/fff&text=1">
        </a>
      </div>
      <div class="carousel-item">
        <a href="#">
          <img src="http://via.placeholder.com/400x150/3498db/fff&text=2">
        </a>
      </div>
      <div class="carousel-item">
        <a href="#">
          <img src="http://via.placeholder.com/400x150/3498db/fff&text=3">
        </a>
      </div>
      <div class="carousel-item">
        <a href="#">
          <img src="http://via.placeholder.com/400x150/3498db/fff&text=4">
        </a>
      </div>
    </div>
    <button class="carousel-control prev">&laquo;</button>
    <button class="carousel-control next">&raquo;</button>
  </div>
  <script>
    class Carousel {
      constructor(config) {
        // 기본 설정과 사용자 지정 설정을 병합
        this.config = Carousel.mergeConfig(config);

        // DOM
        this.carousel = document.querySelector(this.config.selector);
        this.container = this.carousel.querySelector('.carousel-item-container');
        this.item = this.carousel.querySelector('.carousel-item');
        this.items = this.carousel.querySelectorAll('.carousel-item');
        this.prev = this.carousel.querySelector('.prev');
        this.next = this.carousel.querySelector('.next');

        // 캐러셀 아이템의 width
        this.itemWidth = this.item.offsetWidth;
        // 캐러셀 아이템의 height
        this.itemHeight = this.item.offsetHeight;
        // 캐러셀 아이템의 개수
        this.itemLength = this.items.length;

        // 캐러셀 이동 거리
        this.offset = 0;
        // 현재 표시 중인 캐러셀 아이템
        this.currentItem = 1;
        // transition 진행 상태
        this.isTransiting = false;

        this.init();
        this.attachEvent();
      }

      static mergeConfig(config) {
        // 기본 설정 정보
        const defaultConfig = {
          selector: '.carousel',
          duration: 200,
          easing: 'ease-out',
          infinite: true, // Infinite loop sliding
        };

        return { ...defaultConfig, ...config };
      }

      init() {
        /*
          carousel-item의 width/height는 가변적이다.
          따라서 carousel의 윈도우 역할을 하는 carousel 요소의 width/height는
          첫번째 carousel-item의 width/height를 취득해 셋팅한다.
        */
        this.carousel.style.width = this.itemWidth + 'px';
        this.carousel.style.height = this.itemHeight + 'px';

        // 무한 루핑 여부에 따라
      

        /*
          초기 화면에서 나타나는 요소의 크기 조정에 따른 요소의 크기 변화가 보이지 않도록
          캐러셀을 감추고 있다가 요소의 크기 조정이 종료하면 나타낸다.
          opacity는 GPU를 사용하므로 visibility보다 빠르다. visibility는 페인팅에 영향을 준다.
        */
        this.carousel.style.opacity = 1;
      }

      attachEvent() {
        // 핸들러 내부의 this가 Carousel 클래스의 인스턴스를 가리키도록 this를 바인딩한다.
        this.prev.addEventListener('click', this.moveToPrev.bind(this));
        this.next.addEventListener('click', this.moveToNext.bind(this));
        // transition 중에 발생한 이동 요청은 무시한다.
        this.container.addEventListener('transitionend', () => this.isTransiting = false);
      }

      /*
        Infinite looping을 위해 캐러셀 리스트의 처음과 마지막에
        캐러셀 아이템의 첫번째, 마지막 요소를 클론하여 삽입한다.
       */
      insertClone() {
       
      }
      /*
        prev 버튼 이벤트 핸들러
        이전 슬라이더로 이동하기 위해 carousel-container 요소를 오른쪽으로 이동시킨다.
      */
      moveToPrev() {
       
      }

      /*
        next 버튼 이벤트 핸들러
        다음 슬라이더로 이동하기 위해 carousel-container 요소를 왼쪽으로 이동시킨다.
      */
      moveToNext() {
        
      }

      /*
        클론 요소인지 판별한다.
        this.currentItem은 0~this.itemLength + 1 사이의 정수
        this.currentItem이 0이면 첫번째 클론 요소
        this.currentItem이 this.itemLength + 1이면 마지막 클론 요소
      */
      isClone() {
        
      }

      // offset 만큼 carousel-container 요소를 이동시킨다.
      move() {
        
      }

      // offset 만큼 carousel-container 요소를 애니메이션 없이 이동시킨다.
      moveWithoutAnimation() {
        
      }

      // prev, next 버튼 활성화/비활성화 결정
      checkMovable() {

      }
    }

    window.onload = function () {
      const carousel = new Carousel();
      // const carousel = new Carousel({ infinite: false });
    };
  </script>
</body>